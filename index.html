<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9827255236053335"
     crossorigin="anonymous"></script>
    <meta name="google-site-verification" content="_eK3fXMT06ioQvn0APxoIEbT_wGUKNz6M8qcUTVwltQ" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OXゲーム & オセロ オンライン対戦 | 無料ブラウザゲーム</title>
    <meta name="description" content="登録不要・インストール不要ですぐに遊べる無料ブラウザゲーム。友達とオンライン対戦ができる「まるばつゲーム（OXゲーム/三目並べ/Tic Tac Toe）」と「リバーシ（オセロ）」を公開中。PC・スマホ対応。">
    <meta name="keywords" content="まるばつゲーム, 三目並べ, OXゲーム, Tic Tac Toe, リバーシ, オセロ, オンライン対戦, 無料ゲーム, ブラウザゲーム, 暇つぶし">
    
    <meta property="og:title" content="OXゲーム & オセロ オンライン対戦">
    <meta property="og:description" content="ブラウザですぐ遊べる！友達とリアルタイム対戦ができる無料ゲームサイト。">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://SukumizuYoujo.github.io/HIMAJIN/">

    <link rel="icon" type="image/png" href="favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="favicon/favicon.svg" />
    <link rel="shortcut icon" href="favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png" />
    <link rel="manifest" href="favicon/site.webmanifest" />
    
    <style>
        /* === 基本スタイル === */
        :root {
            /* デフォルトカラー定義 */
            --default-o-tic: #d32f2f; /* 赤 */
            --default-x-tic: #1976d2; /* 青 */
            --default-o-othello: #222222; /* 黒 */
            --default-x-othello: #f1f1f1; /* 白 */

            /* 動的に変更されるプレイヤーカラー (初期値はOX用) */
            --player-o-color: var(--default-o-tic);
            --player-x-color: var(--default-x-tic);

            --primary-blue: #1976d2;
            --primary-red: #d32f2f;
            --dark-gray: #607d8b;
            --light-gray-bg: #f0f2f5;
            --white-bg: #ffffff;
            --text-dark: #333;
            --text-light: #666;
            
            /* オセロ用スタイル */
            --othello-board: #008000;
            --othello-border: #333;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--light-gray-bg);
            color: var(--text-dark);
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            overflow: hidden; /* スクロール防止 */
        }

        /* === PC/スマホレイアウト === */
        #mainContainer { display: flex; width: 100%; height: 100vh; overflow: hidden; }
        #gameWrapper {
            flex-grow: 1;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        #sidePanel {
            width: 340px;
            flex-shrink: 0;
            background: var(--white-bg);
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: all 0.3s ease;
            display: none;
        }
        
        @media (max-width: 800px) {
            #mainContainer { flex-direction: column; }
            #gameWrapper { align-items: flex-start; height: 100%; padding: 10px; }
            /* スマホで下部が見切れないように余白調整 */
            .game-container { padding-bottom: 100px; width: 100%; max-width: 100%; }
            #sidePanel { display: none !important; }
        }
        
        @media (min-width: 801px) {
            #mainContainer { flex-direction: row; }
            body.chat-docked #sidePanel {
                display: flex;
            }
            .game-container { max-width: 500px; }
        }

        /* === サイドパネル中身 (チャット専用) === */
        #chatContainer { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; background: #fdfdfd; height: 100%; }
        #chatHeader { padding: 10px; border-bottom: 1px solid #eee; font-weight: bold; text-align: center; }
        #chatMessages { flex-grow: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 12px; }
        .chat-message { max-width: 80%; }
        .chat-bubble { padding: 8px 12px; border-radius: 18px; word-wrap: break-word; }
        .chat-meta { font-size: 0.8rem; color: var(--text-light); margin-bottom: 4px; }
        .chat-message.self { align-self: flex-end; }
        .chat-message.self .chat-bubble { background-color: var(--primary-blue); color: white; border-top-right-radius: 4px; }
        .chat-message.other { align-self: flex-start; }
        .chat-message.other .chat-bubble { background-color: #f1f1f1; color: var(--text-dark); border-top-left-radius: 4px; }
        .chat-notification { align-self: center; font-size: 0.85rem; color: var(--text-light); background: #f9f9f9; padding: 4px 10px; border-radius: 10px; }
        #chatInputContainer { padding: 10px; border-top: 1px solid #eee; display: flex; gap: 10px; background: #fff; }
        #chatInput { flex-grow: 1; border: 1px solid #ccc; border-radius: 8px; padding: 10px; font-size: 1rem; min-width: 0; }
        #chatSendBtn { background: var(--primary-blue); color: white; min-width: 60px; }
        #chatToggleBtn { display: none; }

        /* === ゲームコンテナ中身 === */
        .game-container { max-width: 420px; width: 100%; margin: 0 auto; }
        h1 { margin-bottom: 10px; font-size: 1.5rem; text-align: center; }
        
        #roomIdDisplayHeader { display: none; font-size: 1rem; font-weight: 600; color: var(--text-light); background: #f9f9f9; padding: 5px 10px; border-radius: 8px; margin-bottom: 10px; text-align: center; }
        
        /* 対戦プレイヤー名表示バー */
        #matchPlayerInfo {
            display: none; /* 対戦/観戦中のみ表示 */
            justify-content: space-between;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .player-name-disp { display: flex; align-items: center; gap: 5px; }
        .player-name-disp.active { color: var(--primary-red); text-decoration: underline; } /* 手番の強調 */

        #scoreBoard { display: none; justify-content: space-around; font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; padding: 8px; background: #f9f9f9; border-radius: 8px; }
        .score-win { color: var(--primary-red); }
        .score-lose { color: var(--primary-blue); }
        .score-draw { color: var(--dark-gray); }
        
        #othelloScoreBoard { display: none; justify-content: space-around; font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; padding: 8px; background: #f9f9f9; border-radius: 8px; }

        #status { font-size: 1.1rem; font-weight: 500; min-height: 1.5em; margin-bottom: 15px; text-align: center; }
        
        /* ゲームボード */
        .board-container { position: relative; margin: 20px auto; width: 100%; max-width: 380px; container-type: inline-size; }
        #board { display: grid; width: 100%; aspect-ratio: 1 / 1; margin: auto; transition: opacity 0.3s ease; }
        
        .board-3x3 { grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .board-4x4 { grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .board-5x5 { grid-template-columns: repeat(5, 1fr); gap: 6px; }
        
        .cell { width: 100%; height: 100%; background-color: #f5f5f5; border-radius: 12px; display: flex; justify-content: center; align-items: center; line-height: 1; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        .board-3x3 .cell { font-size: 25cqi; }
        .board-4x4 .cell { font-size: 18cqi; }
        .board-5x5 .cell { font-size: 14cqi; }
        
        /* 色変数の適用 */
        .cell.o { color: var(--player-o-color); }
        .cell.x { color: var(--player-x-color); }
        .cell.highlight-oldest { transform: scale(0.95); }
        .cell.o.highlight-oldest { opacity: 0.5; }
        .cell.x.highlight-oldest { opacity: 0.5; }
        
        /* オセロ用ボードスタイル */
        .board-othello { grid-template-columns: repeat(8, 1fr); background-color: var(--othello-border); border: 5px solid var(--othello-border); gap: 1px; }
        .cell-othello { background-color: var(--othello-board); cursor: pointer; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; position: relative; }
        .hint::after { content: ''; display: block; width: 25%; height: 25%; border-radius: 50%; background-color: rgba(255,255,255,0.3); }
        
        .disc { width: 80%; height: 80%; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: transform 0.3s ease, background-color 0.3s ease; }
        /* 色変数の適用 */
        .disc-black { background-color: var(--player-o-color); }
        .disc-white { background-color: var(--player-x-color); }

        #resultOverlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; font-size: 6rem; font-weight: bold; pointer-events: none; width: 100%; text-align: center; }
        #resultText.win { color: rgba(211, 47, 47, 0.8); }
        #resultText.lose { color: rgba(25, 118, 210, 0.8); }
        #resultText.draw { color: rgba(96, 125, 139, 0.8); }
        #board.game-over { opacity: 0.5; }

        /* 待機ロビーUI */
        #lobbyContainer { display: none; width: 100%; }
        .lobby-section { margin-bottom: 15px; }
        .lobby-section h2 { font-size: 1.1rem; color: var(--text-dark); margin-bottom: 8px; border-bottom: 2px solid var(--light-gray-bg); padding-bottom: 5px; text-align: left; }
        .player-slots { display: grid; grid-template-columns: 1fr; gap: 8px; }
        .player-slot { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 8px; }
        .player-slot-name { font-size: 1rem; font-weight: 500; display: flex; align-items: center; gap: 5px; }
        .player-slot-name.empty { color: #999; font-style: italic; }
        .slot-btn { background: var(--primary-blue); color: white; padding: 8px 12px; font-size: 0.9rem; min-height: 0; }
        .slot-btn.leave, .kick-btn { background: var(--primary-red); color: white; padding: 8px 12px; font-size: 0.9rem; min-height: 0; }
        #spectatorList { list-style: none; padding: 0; margin: 0; max-height: 100px; overflow-y: auto; text-align: left; background: #f9f9f9; border-radius: 8px; }
        #spectatorList li { padding: 8px 12px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        #spectatorList li:last-child { border-bottom: none; }
        #spectatorList li button { padding: 4px 8px; font-size: 0.8rem; min-height: 0; }

        /* コントロールボタン */
        .button-set { display: none; }
        .button-set .controls, .button-set .controls-extra, .button-set .single-control { display: grid; gap: 10px; margin-top: 10px; }
        .button-set .controls, .button-set .controls-extra { grid-template-columns: 1fr 1fr; }
        .button-set .single-control { grid-template-columns: 1fr; }
        
        button, .file-import-label { font-size: 1rem; padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-weight: 500; display: flex; justify-content: center; align-items: center; box-sizing: border-box; min-height: 48px; }
        #onlineBtn { background-color: #4CAF50; color: white; }
        #settingsBtn, #settingsBtnLobby { background-color: var(--dark-gray); color: white; }
        #logBtn, #logBtnLobby, #logBtnPostGame { background-color: var(--dark-gray); color: white; }
        #localResetBtn, #primaryActionBtnLobby, #primaryActionBtnGame, #primaryActionBtnPostGame { background-color: var(--primary-blue); color: white; }
        #primaryActionBtnLobby.ready { background: #4CAF50; }
        #exitBtnLobby, #exitBtnGame, #exitBtnPostGame { background-color: var(--primary-red); color: white; }
        #chatBtnLobby, #chatBtnGame, #chatBtnPostGame { background-color: #009688; color: white; }
        #showRoomListBtn { background-color: #ff9800; color: white; }
        
        #importLogInput { display: none; }
        .file-import-label { background-color: var(--dark-gray); color: white; } /* 色修正済み */
        #helpBtn { background-color: #ff7043; color: white; } /* 遊び方ボタン用 */
        
        button:disabled { background-color: #b0bec5; cursor: not-allowed; }
        button:hover { opacity: 0.9; }

        /* モーダル */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.5); align-items: center; justify-content: center; animation-name: fadeIn; animation-duration: 0.3s; }
        .modal-content { background-color: var(--white-bg); margin: auto; padding: 25px; border-radius: 10px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); animation-name: modalopen; animation-duration: 0.4s; box-sizing: border-box; max-height: 90vh; overflow-y: auto; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 20px; }
        .modal-header h2 { margin: 0; color: var(--text-dark); font-size: 1.2rem; }
        .close-btn { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
        @keyframes fadeIn { from {opacity: 0;} to {opacity: 1;} }
        @keyframes modalopen { from {transform: scale(0.9); opacity: 0;} to {transform: scale(1); opacity: 1;} }

        /* スマホ用レスポンシブ修正 (チャットモーダル等) */
        @media (max-width: 600px) {
            #chatModal .modal-content {
                width: 100%;
                height: 100%;
                max-width: 100%;
                max-height: 100%;
                margin: 0;
                border-radius: 0;
                padding: 15px;
            }
            #chatContainerModal {
                height: 100%;
            }
            .modal-content {
                width: 95%;
                padding: 15px;
            }
        }

        /* ログモーダル */
        #logContent { background-color: #f9f9f9; border: 1px solid #eee; border-radius: 5px; padding: 15px; height: 60vh; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; }
        .log-list-item { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 10px; font-size: 1.1rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
        .log-list-item:hover { background: #f0f2f5; border-color: var(--primary-blue); }
        .log-detail-controls { display: flex; justify-content: space-between; gap: 10px; margin-bottom: 15px; }
        .log-entry { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
        .log-text { flex-grow: 1; }
        .mini-board { display: grid; gap: 4px; width: 90px; height: 90px; flex-shrink: 0; border: 1px solid #ccc; background-color: #e0e0e0; }
        .mini-cell { width: 100%; height: 100%; background-color: #f5f5f5; display: flex; justify-content: center; align-items: center; font-weight: bold; line-height: 1; }
        .mini-cell.o { color: var(--player-o-color); }
        .mini-cell.x { color: var(--player-x-color); }
        .mini-board.othello-log { gap: 1px; background-color: var(--othello-border); border-width: 2px; }
        .mini-cell.othello-cell { background-color: var(--othello-board); }
        .mini-disc { width: 80%; height: 80%; border-radius: 50%; }
        .mini-disc.o { background-color: var(--player-o-color); }
        .mini-disc.x { background-color: var(--player-x-color); }

        /* 設定モーダル */
        #settingsModal .modal-content { overflow-y: auto; }
        .setting-item { display: flex; justify-content: space-between; align-items: center; padding: 18px 10px; border-bottom: 1px solid #eee; transition: opacity 0.3s ease; }
        .setting-item label, .setting-item .setting-label { font-size: 1.1rem; color: var(--text-dark); font-weight: 500; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-blue); }
        input:checked + .slider:before { transform: translateX(22px); }
        .setting-item.disabled { opacity: 0.5; }
        .radio-group { display: flex; gap: 10px; }
        .radio-group label { font-size: 0.95rem; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; }
        .radio-group input[type="radio"] { display: none; }
        .radio-group input[type="radio"]:checked + label { background-color: var(--primary-blue); color: white; border-color: var(--primary-blue); }
        .radio-group input[type="radio"]:disabled + label { background-color: #e0e0e0; border-color: #ccc; color: #999; cursor: not-allowed; }
        input[type="number"] { width: 60px; padding: 5px 8px; font-size: 1rem; border-radius: 6px; border: 1px solid #ccc; }

        /* カラーパレット */
        .color-palette { display: flex; flex-wrap: wrap; gap: 10px; padding: 5px; }
        .color-btn { width: 32px; height: 32px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; padding: 0; min-height: 32px; transition: transform 0.2s, border-color 0.2s; }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.active { border-color: #333; transform: scale(1.1); box-shadow: 0 0 0 2px rgba(0,0,0,0.2); }
        .color-btn.disabled { opacity: 0.2; cursor: not-allowed; pointer-events: none; border: 2px solid #ccc; }
        .reset-color-btn { margin-top: 10px; padding: 5px 10px; font-size: 0.9rem; background: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; width: 100%; min-height: 36px; }

        /* オンラインモーダル */
        .online-item { display: flex; flex-direction: column; gap: 10px; padding: 10px 0; }
        .online-item label { font-size: 1rem; color: var(--text-dark); font-weight: 500; text-align: left; }
        #onlineModal input[type="text"] { width: 100%; padding: 12px; font-size: 1.1rem; border: 1px solid #ccc; border-radius: 8px; box-sizing: border-box; }
        #onlineModal .online-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        #roomIdDisplay { font-weight: bold; font-size: 1.2rem; color: var(--primary-blue); padding: 10px; background: #f0f2f5; border-radius: 8px; margin-top: 10px; display: none; }
        .public-room-toggle { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; }
        
        /* ルーム一覧 */
        #roomListContent { height: 60vh; display: flex; flex-direction: column; }
        #publicRoomList { flex-grow: 1; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; margin-bottom: 15px; }
        .room-list-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: background-color 0.2s; }
        .room-list-item:hover { background-color: #f9f9f9; }
        .room-list-id { font-weight: bold; color: var(--primary-blue); }
        .room-list-count { font-size: 0.9rem; color: var(--text-light); }
        .room-list-join-btn { background-color: var(--primary-blue); color: white; padding: 8px 12px; font-size: 0.9rem; min-height: 0; }
        #roomListPagination { display: flex; justify-content: space-between; align-items: center; }
        
        /* 遊び方スタイル */
        #helpContent h3 { border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 20px; margin-bottom: 10px; color: var(--primary-blue); }
        #helpContent ul { padding-left: 20px; margin-bottom: 10px; }
        #helpContent li { margin-bottom: 5px; }

        /* 確認モーダル */
        #exitConfirmModal .modal-content, #kickConfirmModal .modal-content { max-width: 400px; }
        #exitConfirmControls, #kickConfirmControls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        #confirmExitBtn, #confirmKickBtn { background-color: var(--primary-red); color: white; }
        #cancelExitBtn, #cancelKickBtn { background-color: var(--dark-gray); color: white; }
    </style>
</head>
<body class="chat-docked">

    <div id="mainContainer">
        
        <div id="gameWrapper">
            
            <div id="gameMainArea" style="width: 100%; min-height: 100%; display: flex; justify-content: center; align-items: center; padding-bottom: 80px; box-sizing: border-box;">
                
                <div class="game-container">
                    <h1 id="gameTitle">OXゲーム</h1>
                    <div id="roomIdDisplayHeader"></div>
                    
                    <div id="matchPlayerInfo">
                        <span id="playerDisplayO" class="player-name-disp"></span>
                        <span id="playerDisplayX" class="player-name-disp"></span>
                    </div>
                    <div id="scoreBoard">
                        <span class="score-win">WIN: <span id="scoreWinCount">0</span></span>
                        <span class="score-lose">LOSE: <span id="scoreLoseCount">0</span></span>
                        <span class="score-draw">DRAW: <span id="scoreDrawCount">0</span></span>
                    </div>
    
                    <div id="othelloScoreBoard">
                        <span>黒(O): <span id="othelloScoreBlack">2</span></span>
                        <span>白(X): <span id="othelloScoreWhite">2</span></span>
                    </div>
                    <div id="status">ようこそ！</div>
    
                    <div id="lobbyContainer">
                        <div class="lobby-section">
                            <h2>対戦スロット</h2>
                            <div class="player-slots">
                                <div class="player-slot" id="slot-O">
                                    <span class="player-slot-name empty">(O) 空き</span>
                                    <button class="slot-btn" data-slot="O">参加する</button>
                                </div>
                                <div class="player-slot" id="slot-X">
                                    <span class="player-slot-name empty">(X) 空き</span>
                                    <button class="slot-btn" data-slot="X">参加する</button>
                                </div>
                            </div>
                        </div>
                        <div class="lobby-section">
                            <h2>観戦者</h2>
                            <ul id="spectatorList"></ul>
                        </div>
                    </div>
    
                    <div class="board-container" id="boardContainer">
                        <div id="resultOverlay"><span id="resultText"></span></div>
                        <div id="board" class="board-3x3"></div>
                    </div>
    
                    <div id="buttonContainer">
                        <div class="button-set" id="buttonSet-local" style="display: block;">
                            <div class="controls">
                                <button id="onlineBtn">オンライン対戦</button>
                                <button id="settingsBtn">設定</button>
                            </div>
                            <div class="controls-extra">
                                <button id="localResetBtn">リセット</button>
                                <button id="logBtn">ログ確認</button>
                            </div>
                            <div class="controls-extra">
                                <button id="helpBtn">遊び方</button>
                                <label for="importLogInput" class="file-import-label">ログ読込</label>
                                <input type="file" id="importLogInput" accept=".json,.txt">
                            </div>
                        </div>
    
                        <div class="button-set" id="buttonSet-lobby">
                            <div class="controls">
                                <button id="primaryActionBtnLobby">準備完了</button>
                                <button id="settingsBtnLobby">設定</button>
                            </div>
                            <div class="controls-extra">
                                <button id="chatBtnLobby">チャット</button>
                                <button id="logBtnLobby">ログ確認 (全試合)</button>
                            </div>
                            <div class="single-control">
                                <button id="exitBtnLobby">退出</button>
                            </div>
                        </div>
                        
                        <div class="button-set" id="buttonSet-in-game">
                            <div class="controls">
                                <button id="primaryActionBtnGame">降参</button>
                                <button id="chatBtnGame">チャット</button>
                            </div>
                            <div class="single-control">
                                <button id="exitBtnGame">退出</button>
                            </div>
                        </div>
                        
                        <div class="button-set" id="buttonSet-post-game">
                            <div class="single-control">
                                <button id="primaryActionBtnPostGame">待機画面に戻る</button>
                            </div>
                            <div class="controls-extra">
                                <button id="logBtnPostGame">ログ確認 (現試合)</button>
                                <button id="chatBtnPostGame">チャット</button>
                            </div>
                            <div class="single-control">
                                <button id="exitBtnPostGame">退出</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <section id="seoContent" style="
                width: 100%;
                padding: 40px 20px; 
                color: #555; 
                line-height: 1.8; 
                background-color: #f0f2f5; /* 背景色をつけて区分け */
                border-top: 1px solid #ddd;
                text-align: left; 
                font-size: 0.95rem;
                box-sizing: border-box;
            ">
                <div style="max-width: 600px; margin: 0 auto;">
                    <h2 style="
                        font-size: 1.2rem; 
                        margin-bottom: 20px; 
                        color: var(--primary-blue); 
                        text-align: center; 
                        border-bottom: 2px solid #fff;
                        padding-bottom: 10px;
                    ">ブラウザですぐ遊べる無料ボードゲーム</h2>
                    
                    <p style="margin-bottom: 20px;">
                        「board-taisen.com」は、インストール不要ですぐに遊べる無料Webゲームサイトです。
                        発行されたIDを共有するだけで、友達と<strong>オンライン対戦</strong>が楽しめます。
                    </p>
    
                    <h3 style="font-size: 1rem; font-weight: bold; margin-bottom: 10px; color: #333;">収録ゲーム</h3>
                    <ul style="padding-left: 20px; margin-bottom: 0;">
                        <li style="margin-bottom: 8px;"><strong>まるばつゲーム (三目並べ):</strong> 定番のOXゲーム。3x3、4x4、5x5の盤面や、3つ目以降が消えるFIFOモードも搭載。</li>
                        <li><strong>リバーシ (オセロ):</strong> 白と黒の石を挟んでひっくり返す頭脳戦。スマホやPCで本格的な8x8対戦が可能。</li>
                    </ul>
                </div>
            </section>
            </div>

        <div id="sidePanel" style="display: none;">
            <div id="chatContainer">
                <div id="chatHeader">チャット</div>
                <div id="chatMessages"></div>
                <div id="chatInputContainer">
                    <input type="text" id="chatInput" placeholder="メッセージを入力..." maxlength="200">
                    <button id="chatSendBtn">送信</button>
                </div>
            </div>
        </div>
        
    </div>

    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="helpModalTitle">遊び方と注意事項</h2>
                <span class="close-btn" data-modal-id="helpModal">&times;</span>
            </div>
            <div id="helpContent" style="text-align: left; line-height: 1.6;"></div>
        </div>
    </div>

    <div id="logModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="logModalTitle">ゲームログ</h2>
                <span class="close-btn" data-modal-id="logModal">&times;</span>
            </div>
            <div id="logContent"></div>
        </div>
    </div>
    
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ゲーム設定</h2>
                <span class="close-btn" data-modal-id="settingsModal">&times;</span>
            </div>
            
            <div class="setting-item" id="gameSelectContainer">
                <span class="setting-label">ゲーム切替</span>
                <div class="radio-group" id="gameTypeRadio">
                    <input type="radio" id="gameTictactoe" name="gameType" value="tictactoe" checked>
                    <label for="gameTictactoe">OXゲーム</label>
                    <input type="radio" id="gameOthello" name="gameType" value="othello">
                    <label for="gameOthello">オセロ</label>
                </div>
            </div>

            <div class="setting-item" id="colorSelectContainer" style="display: none; flex-direction: column; align-items: flex-start;">
                <span class="setting-label" id="colorPaletteLabel" style="margin-bottom: 10px;">自分の駒の色を変更</span>
                <div class="color-palette">
                    <button class="color-btn" style="background-color: #d32f2f;" data-color="#d32f2f"></button>
                    <button class="color-btn" style="background-color: #1976d2;" data-color="#1976d2"></button>
                    <button class="color-btn" style="background-color: #e91e63;" data-color="#e91e63"></button>
                    <button class="color-btn" style="background-color: #9c27b0;" data-color="#9c27b0"></button>
                    <button class="color-btn" style="background-color: #673ab7;" data-color="#673ab7"></button>
                    <button class="color-btn" style="background-color: #3f51b5;" data-color="#3f51b5"></button>
                    <button class="color-btn" style="background-color: #03a9f4;" data-color="#03a9f4"></button>
                    <button class="color-btn" style="background-color: #00bcd4;" data-color="#00bcd4"></button>
                    <button class="color-btn" style="background-color: #009688;" data-color="#009688"></button>
                    <button class="color-btn" style="background-color: #4caf50;" data-color="#4caf50"></button>
                    <button class="color-btn" style="background-color: #ffeb3b;" data-color="#ffeb3b"></button>
                    <button class="color-btn" style="background-color: #ff9800;" data-color="#ff9800"></button>
                    <button class="color-btn" style="background-color: #795548;" data-color="#795548"></button>
                    <button class="color-btn" style="background-color: #607d8b;" data-color="#607d8b"></button>
                    <button class="color-btn" style="background-color: #333333;" data-color="#333333"></button>
                </div>
                <button class="reset-color-btn" id="resetColorBtn">デフォルト色に戻す</button>
                <p style="font-size:0.8rem; color:#666; margin-top:5px;">※相手が使用中の色は選べません</p>
            </div>
            
            <div class="setting-item" id="boardSizeContainer">
                <span class="setting-label">盤面サイズ</span>
                <div class="radio-group" id="boardSizeRadio">
                    <input type="radio" id="size3" name="boardSize" value="3" checked>
                    <label for="size3">3x3</label>
                    <input type="radio" id="size4" name="boardSize" value="4">
                    <label for="size4">4x4</label>
                    <input type="radio" id="size5" name="boardSize" value="5">
                    <label for="size5">5x5</label>
                </div>
            </div>
            <div class="setting-item" id="playerOrderContainer">
                <span class="setting-label">先手/後手</span>
                <div class="radio-group" id="playerOrderRadio">
                    <input type="radio" id="orderAssign" name="playerOrder" value="assigned" checked>
                    <label for="orderAssign">指定</label>
                    <input type="radio" id="orderRand" name="playerOrder" value="random">
                    <label for="orderRand">ランダム</label>
                </div>
            </div>
            <div class="setting-item" id="limitModeContainer">
                <label for="limitMode">3つまで (FIFO)</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="limitMode">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item" id="highlightOptionContainer">
                <label for="highlightOldest">古い駒をハイライト</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="highlightOldest">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item" id="maxPlayersContainer">
                <label for="maxPlayersInput">最大人数 (2-100)</label>
                <input type="number" id="maxPlayersInput" value="10" min="2" max="100">
            </div>
            <div class="setting-item" id="dockChatContainer">
                <label for="dockChatToggle">チャットを右に固定 (PC)</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="dockChatToggle" checked> <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <div id="onlineModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>オンライン対戦</h2>
                <span class="close-btn" data-modal-id="onlineModal">&times;</span>
            </div>
            <div class="online-item">
                <label for="usernameInputOnline">あなたの名前 (20文字以内)</label>
                <input type="text" id="usernameInputOnline" placeholder="名前を入力..." maxlength="20">
            </div>
            <div class="single-control" style="margin-bottom: 20px;">
                <button id="showRoomListBtn">公開ルーム一覧</button>
            </div>
            <div class="online-item">
                <label for="roomIdInput">ルームID (参加する場合)</label>
                <input type="text" id="roomIdInput" placeholder="参加するIDを入力...">
            </div>
            <div class="online-controls">
                <button id="createRoomBtn">ルーム作成</button>
                <button id="joinRoomBtn">IDで参加</button>
            </div>
             <div class="public-room-toggle">
                <label for="isPublicToggle">公開ルームとして作成</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="isPublicToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div id="roomIdDisplay"></div>
        </div>
    </div>
    
    <div id="roomListModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>公開ルーム一覧</h2>
                <span class="close-btn" data-modal-id="roomListModal">&times;</span>
            </div>
            <div id="roomListContent">
                <div id="publicRoomList"></div>
                <div id="roomListPagination">
                    <button id="roomListRefreshBtn">更新</button>
                    <div>
                        <button id="roomListPagePrev" disabled>&lt; 前へ</button>
                        <span id="roomListPageNum">1 / 1</span>
                        <button id="roomListPageNext" disabled>次へ &gt;</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="exitConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>退出確認</h2>
                <span class="close-btn" data-modal-id="exitConfirmModal">&times;</span>
            </div>
            <p>本当にルームを退出しますか？<br>現在のスコアとログはリセットされます。</p>
            <div id="exitConfirmControls">
                <button id="cancelExitBtn">キャンセル</button>
                <button id="confirmExitBtn">退出する</button>
            </div>
        </div>
    </div>

    <div id="kickConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>確認</h2>
                <span class="close-btn" data-modal-id="kickConfirmModal">&times;</span>
            </div>
            <p id="kickConfirmText"></p>
            <div id="kickConfirmControls">
                <button id="cancelKickBtn">キャンセル</button>
                <button id="confirmKickBtn">実行する</button>
            </div>
        </div>
    </div>

    <div id="chatModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>チャット</h2>
                <span class="close-btn" data-modal-id="chatModal">&times;</span>
            </div>
            <div id="chatContainerModal"></div>
        </div>
    </div>

    <script>
        let showLogList;
        let showMatchLogDetail;
        let exportMatchLog;
        let handleCellClick;

        document.addEventListener('DOMContentLoaded', () => {
            
            const serverUrl = 'wss://ox-online.onrender.com';

            // DOM参照
            const body = document.body;
            const statusDisplay = document.getElementById('status');
            const boardElement = document.getElementById('board');
            const boardContainer = document.getElementById('boardContainer');
            const importLogInput = document.getElementById('importLogInput');
            const settingsBtn = document.getElementById('settingsBtn');
            const onlineBtn = document.getElementById('onlineBtn');
            const roomIdDisplayHeader = document.getElementById('roomIdDisplayHeader');
            const sidePanel = document.getElementById('sidePanel');
            const gameTitle = document.getElementById('gameTitle');
            const matchPlayerInfo = document.getElementById('matchPlayerInfo');
            const playerDisplayO = document.getElementById('playerDisplayO');
            const playerDisplayX = document.getElementById('playerDisplayX');
            
            const buttonSetLocal = document.getElementById('buttonSet-local');
            const buttonSetLobby = document.getElementById('buttonSet-lobby');
            const buttonSetInGame = document.getElementById('buttonSet-in-game');
            const buttonSetPostGame = document.getElementById('buttonSet-post-game');
            
            const localResetBtn = document.getElementById('localResetBtn');
            const logBtn = document.getElementById('logBtn');
            const logBtnLobby = document.getElementById('logBtnLobby');
            const logBtnPostGame = document.getElementById('logBtnPostGame');
            const settingsBtnLobby = document.getElementById('settingsBtnLobby');
            const primaryActionBtnLobby = document.getElementById('primaryActionBtnLobby');
            const primaryActionBtnGame = document.getElementById('primaryActionBtnGame');
            const primaryActionBtnPostGame = document.getElementById('primaryActionBtnPostGame');
            const exitBtnLobby = document.getElementById('exitBtnLobby');
            const exitBtnGame = document.getElementById('exitBtnGame');
            const exitBtnPostGame = document.getElementById('exitBtnPostGame');
            
            const chatBtnLobby = document.getElementById('chatBtnLobby');
            const chatBtnGame = document.getElementById('chatBtnGame');
            const chatBtnPostGame = document.getElementById('chatBtnPostGame');
            
            const scoreBoard = document.getElementById('scoreBoard');
            const scoreWinCount = document.getElementById('scoreWinCount');
            const scoreLoseCount = document.getElementById('scoreLoseCount');
            const scoreDrawCount = document.getElementById('scoreDrawCount');
            const othelloScoreBoard = document.getElementById('othelloScoreBoard');
            const resultOverlay = document.getElementById('resultOverlay');
            const resultText = document.getElementById('resultText');

            const modals = document.querySelectorAll('.modal');
            const closeBtns = document.querySelectorAll('.close-btn');
            const logModal = document.getElementById('logModal');
            const logModalTitle = document.getElementById('logModalTitle');
            const logContent = document.getElementById('logContent');
            
            const settingsModal = document.getElementById('settingsModal');
            const boardSizeRadios = document.querySelectorAll('input[name="boardSize"]');
            const playerOrderRadios = document.querySelectorAll('input[name="playerOrder"]');
            const limitModeCheckbox = document.getElementById('limitMode');
            const highlightOldestCheckbox = document.getElementById('highlightOldest');
            const boardSizeContainer = document.getElementById('boardSizeContainer');
            const playerOrderContainer = document.getElementById('playerOrderContainer');
            const limitModeContainer = document.getElementById('limitModeContainer');
            const highlightOptionContainer = document.getElementById('highlightOptionContainer');
            const dockChatToggle = document.getElementById('dockChatToggle');
            const dockChatContainer = document.getElementById('dockChatContainer');
            const maxPlayersInput = document.getElementById('maxPlayersInput');
            const maxPlayersContainer = document.getElementById('maxPlayersContainer');
            
            const onlineModal = document.getElementById('onlineModal');
            const usernameInputOnline = document.getElementById('usernameInputOnline');
            const createRoomBtn = document.getElementById('createRoomBtn');
            const joinRoomBtn = document.getElementById('joinRoomBtn');
            const roomIdInput = document.getElementById('roomIdInput');
            const roomIdDisplay = document.getElementById('roomIdDisplay');
            const isPublicToggle = document.getElementById('isPublicToggle');
            const showRoomListBtn = document.getElementById('showRoomListBtn');
            
            const exitConfirmModal = document.getElementById('exitConfirmModal');
            const confirmExitBtn = document.getElementById('confirmExitBtn');
            const cancelExitBtn = document.getElementById('cancelExitBtn');
            const kickConfirmModal = document.getElementById('kickConfirmModal');
            const kickConfirmText = document.getElementById('kickConfirmText');
            const confirmKickBtn = document.getElementById('confirmKickBtn');
            const cancelKickBtn = document.getElementById('cancelKickBtn');
            
            const chatModal = document.getElementById('chatModal');
            const chatContainer = document.getElementById('chatContainer');
            const chatContainerModal = document.getElementById('chatContainerModal');
            const chatToggleBtn = document.getElementById('chatToggleBtn');
            const chatMessages = document.getElementById('chatMessages');
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');

            const lobbyContainer = document.getElementById('lobbyContainer');
            const playerSlotO = document.getElementById('slot-O');
            const playerSlotX = document.getElementById('slot-X');
            const spectatorList = document.getElementById('spectatorList');
            
            const roomListModal = document.getElementById('roomListModal');
            const publicRoomList = document.getElementById('publicRoomList');
            const roomListRefreshBtn = document.getElementById('roomListRefreshBtn');
            const roomListPagePrev = document.getElementById('roomListPagePrev');
            const roomListPageNext = document.getElementById('roomListPageNext');
            const roomListPageNum = document.getElementById('roomListPageNum');

            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const helpModalTitle = document.getElementById('helpModalTitle');
            const helpContent = document.getElementById('helpContent');

            // ゲーム状態変数
            let gameActive = true;
            let boardSize = 3;
            let winningConditions = [];
            let boardState = [];
            let currentPlayer = 'O';
            let oQueue = [];
            let xQueue = [];
            let sessionLog = [];
            let currentGameLog = [];
            let turnCounter = 0;
            
            let username = '';
            let currentRoomId = '';
            let socket = null;
            let isOnlineGame = false;
            let myPlayerMark = ''; 
            let isHost = false;
            let scores = { win: 0, lose: 0, draw: 0 };
            let currentRoomPage = 1;
            let autoReturnTimer = null; 
            let isReady = false; 
            let usernameToKick = ''; 
            
            let currentGameType = 'tictactoe';
            let gameLogic = {}; 
            let secretCode = ['5', '4', '5', '4', '5', '4', '3', '4', '5'];
            let secretIndex = 0;

            let myLocalColorPref = null; 
            let currentRoomColors = { O: null, X: null };
            let currentRoomPlayerNames = { O: '?', X: '?' }; // プレイヤー名保存用

            // 関数定義
            
            handleCellClick = (e) => {
                gameLogic.handleCellClick(e);
            }

            function applyColors(colors) {
                currentRoomColors = colors || { O: null, X: null };
                const defO = (currentGameType === 'othello') ? '#222222' : '#d32f2f';
                const defX = (currentGameType === 'othello') ? '#f1f1f1' : '#1976d2';
                const colorO = currentRoomColors.O || defO;
                const colorX = currentRoomColors.X || defX;
                document.documentElement.style.setProperty('--player-o-color', colorO);
                document.documentElement.style.setProperty('--player-x-color', colorX);
                updatePaletteUI();
            }

            function updatePaletteUI() {
                const buttons = document.querySelectorAll('.color-btn');
                const mySlot = (myPlayerMark === 'O' || myPlayerMark === 'X') ? myPlayerMark : null;
                buttons.forEach(btn => {
                    const color = btn.dataset.color;
                    btn.classList.remove('active', 'disabled');
                    if (myLocalColorPref === color) { btn.classList.add('active'); }
                    if (isOnlineGame && mySlot) {
                        const opponentSlot = (mySlot === 'O') ? 'X' : 'O';
                        const opponentColor = currentRoomColors[opponentSlot];
                        if (opponentColor && opponentColor === color) { btn.classList.add('disabled'); }
                    }
                });
            }
            
            function switchGame(newGameType) {
                currentGameType = newGameType;
                if (newGameType === 'othello') {
                    gameLogic = othelloLogic;
                    gameTitle.textContent = othelloLogic.gameName;
                    const radio = document.getElementById(`gameOthello`); if(radio) radio.checked = true;
                    if(isOnlineGame) scoreBoard.style.display = 'flex'; else scoreBoard.style.display = 'none';
                    othelloScoreBoard.style.display = (newGameType === 'othello' && isOnlineGame) ? 'flex' : 'none';
                } else {
                    gameLogic = ticTacToeLogic;
                    gameTitle.textContent = ticTacToeLogic.gameName;
                    const radio = document.getElementById(`gameTictactoe`); if(radio) radio.checked = true;
                    if(isOnlineGame) scoreBoard.style.display = 'flex'; else scoreBoard.style.display = 'none';
                    othelloScoreBoard.style.display = 'none';
                }
                applyColors(currentRoomColors);
                gameLogic.initializeBoard(isOnlineGame);
                lockSettings(isOnlineGame && !isHost);
                updateHelpContent();
            }
            
            function lockSettings(lock) {
                settingsBtn.disabled = false; settingsBtnLobby.disabled = false;
                const isGuestOnline = isOnlineGame && !isHost;
                const isLocal = !isOnlineGame;
                const tictactoeSettingsLocked = lock || isGuestOnline || (currentGameType !== 'tictactoe');
                boardSizeRadios.forEach(radio => radio.disabled = tictactoeSettingsLocked);
                limitModeCheckbox.disabled = tictactoeSettingsLocked;
                highlightOldestCheckbox.disabled = tictactoeSettingsLocked;
                boardSizeContainer.style.display = (currentGameType !== 'tictactoe') ? 'none' : 'flex';
                limitModeContainer.style.display = (currentGameType !== 'tictactoe') ? 'none' : 'flex';
                highlightOptionContainer.style.display = (currentGameType !== 'tictactoe') ? 'none' : 'flex';
                boardSizeContainer.classList.toggle('disabled', tictactoeSettingsLocked);
                limitModeContainer.classList.toggle('disabled', tictactoeSettingsLocked);
                highlightOptionContainer.classList.toggle('disabled', tictactoeSettingsLocked);
                const playerOrderLocked = lock || isLocal;
                playerOrderRadios.forEach(radio => radio.disabled = playerOrderLocked);
                playerOrderContainer.style.display = 'flex';
                playerOrderContainer.classList.toggle('disabled', playerOrderLocked);
                const maxPlayersLocked = lock || isLocal;
                maxPlayersInput.disabled = maxPlayersLocked;
                maxPlayersContainer.classList.toggle('disabled', maxPlayersLocked);
                const gameSelectLocked = lock || isGuestOnline;
                document.querySelectorAll('input[name="gameType"]').forEach(radio => radio.disabled = gameSelectLocked);
                dockChatToggle.disabled = false;
                dockChatContainer.classList.toggle('disabled', false);
                if (!lock) { updateSettingDependencies(false); }
            }
            
            function fullReset() {
                if (autoReturnTimer) clearTimeout(autoReturnTimer); autoReturnTimer = null;
                switchGame(currentGameType); 
                applySettings(getSettingsFromUI(), false);
                isOnlineGame = false; myPlayerMark = ''; isHost = false; currentRoomId = '';
                if (socket && socket.readyState === WebSocket.OPEN) socket.close();
                lockSettings(false); onlineBtn.disabled = false;
                scoreBoard.style.display = 'none'; othelloScoreBoard.style.display = 'none'; matchPlayerInfo.style.display = 'none';
                scores = { win: 0, lose: 0, draw: 0 }; updateScoreDisplay();
                showButtonSet('local');
                lobbyContainer.style.display = 'none'; boardContainer.style.display = 'block';
                sidePanel.style.display = 'none'; if(chatToggleBtn) chatToggleBtn.style.display = 'none';
                document.body.classList.add('chat-dock-hidden');
                createRoomBtn.disabled = false; joinRoomBtn.disabled = false; roomIdInput.disabled = false; roomIdInput.value = '';
                roomIdDisplay.style.display = 'none'; roomIdDisplayHeader.style.display = 'none';
                statusDisplay.textContent = 'ようこそ！';
                currentRoomColors = { O: null, X: null };
                applyColors({O: myLocalColorPref, X: null}); 
                handleResize();
            }

            function getSettingsFromUI() {
                const size = document.querySelector('input[name="boardSize"]:checked').value;
                const order = document.querySelector('input[name="playerOrder"]:checked').value;
                return {
                    boardSize: parseInt(size, 10),
                    playerOrder: order,
                    limitMode: limitModeCheckbox.checked,
                    highlightOldest: highlightOldestCheckbox.checked,
                    maxPlayers: parseInt(maxPlayersInput.value, 10)
                };
            }
            
            function applySettings(settings, isOnlineEvent = false) {
                if (settings.boardSize) {
                    boardSize = settings.boardSize;
                    const radio = document.getElementById(`size${boardSize}`);
                    if (radio) radio.checked = true;
                }
                if (settings.playerOrder) {
                    const radio = document.querySelector(`input[name="playerOrder"][value="${settings.playerOrder}"]`);
                    if(radio) radio.checked = true;
                }
                limitModeCheckbox.checked = settings.limitMode;
                highlightOldestCheckbox.checked = settings.highlightOldest;
                maxPlayersInput.value = settings.maxPlayers || 10; 
                updateSettingDependenciesUI();
                if(isOnlineEvent && gameLogic.initializeBoard) { gameLogic.initializeBoard(true); }
            }
            
            function updateSettingDependenciesUI() {
                const settings = getSettingsFromUI();
                boardSize = settings.boardSize;
                const is3x3 = (boardSize === 3);
                limitModeContainer.classList.toggle('disabled', !is3x3);
                limitModeCheckbox.disabled = !is3x3;
                if (!is3x3) limitModeCheckbox.checked = false;
                const isFifoOn = limitModeCheckbox.checked;
                highlightOptionContainer.classList.toggle('disabled', !isFifoOn);
                highlightOldestCheckbox.disabled = !isFifoOn;
                if (!isFifoOn) highlightOldestCheckbox.checked = false;
                if (currentGameType === 'tictactoe') ticTacToeLogic.updateOldestHighlight(); 
            }
            
            function updateSettingDependencies(notifyServer = true) {
                updateSettingDependenciesUI();
                if (!isOnlineGame) gameLogic.initializeBoard(false); 
                if (notifyServer) sendSettingsUpdate();
            }

            function updateHelpContent() {
                const helpContent = document.getElementById('helpContent');
                if (!helpContent) return; // エラー防止

                let html = '';
                
                // 1. ゲームごとのルール説明
                if (currentGameType === 'othello') {
                    html += `
                        <h3>オセロの遊び方</h3>
                        <p>黒(先手)と白(後手)に分かれて、8x8の盤面で石を取り合います。</p>
                        <ul>
                            <li><strong>基本ルール:</strong> 相手の石を自分の石で挟むと、挟んだ石が自分の色に変わります。</li>
                            <li><strong>勝利条件:</strong> 盤面が埋まるか、両者とも置ける場所がなくなったら終了です。石の多い方が勝ちです。</li>
                            <li><strong>パス:</strong> 置ける場所がない場合は自動的にパスとなり、相手の番になります。</li>
                            <li><strong>ヒント:</strong> 置ける場所にはうっすらと丸いマークが表示されます。</li>
                        </ul>
                    `;
                } else {
                    html += `
                        <h3>OXゲームの遊び方</h3>
                        <p>〇(先手)と×(後手)に分かれて、マスを取り合います。</p>
                        <ul>
                            <li><strong>基本ルール:</strong> 縦・横・斜めのいずれか一列に、自分の駒を既定の数だけ並べれば勝ちです。</li>
                            <li><strong>盤面サイズ:</strong> 設定から 3x3, 4x4, 5x5 を選べます。サイズによって勝利に必要な数が変わります(例: 5x5なら5つ並べば勝ち等)。</li>
                            <li><strong>特殊ルール (FIFOモード):</strong> 設定で「3つまで」をオンにすると、盤面に置ける駒が3つまでになります。4つ目を置くと一番古い駒が消えます(3x3専用)。</li>
                        </ul>
                    `;
                }

                // 2. 共通の説明(オンライン対戦の手順と注意事項)
                html += `
                    <h3>オンライン対戦の遊び方</h3>
                    <ol>
                        <li>「オンライン対戦」ボタンを押します。</li>
                        <li>名前を入力し、「ルーム作成」で部屋を作ります(ホストになります)。</li>
                        <li>
                            <strong>ルームの公開設定:</strong>
                            <ul>
                                <li><span style="color:#4CAF50; font-weight:bold;">公開 (オン):</span> 「公開ルーム一覧」に表示され、誰でも参加できます。</li>
                                <li><span style="color:#666; font-weight:bold;">非公開 (オフ):</span> 一覧には表示されません。ルームIDを伝えた友達だけが参加できます。</li>
                            </ul>
                        </li>
                        <li>友達は「IDで参加」にIDを入力するか、公開ルーム一覧から参加します。</li>
                        <li>「参加する」ボタンでスロットに入り、「準備完了」を押すと試合開始です。</li>
                    </ol>

                    <h3>注意事項</h3>
                    <ul>
                        <li>オンライン対戦は接続が切れるとルームから退出となります。</li>
                        <li>荒らし行為や不適切な名前の使用はお控えください。ホストはプレイヤーをキック(強制退出)できます。</li>
                        <li>60分間操作がないルームは自動的に削除されます。</li>
                        <li style="color: #d32f2f;"><strong>サーバーの起動について:</strong> 無料サーバーを使用しているため、一定時間アクセスがないとスリープ状態になります。その場合、「オンライン対戦」ボタンを押してから接続までに<strong>1分程度時間がかかることがあります</strong>が、そのままお待ちください。</li>
                    </ul>
                `;

                helpContent.innerHTML = html;
            }

            // ゲームロジック
            const ticTacToeLogic = {
                gameName: 'OXゲーム',
                generateWinningConditions: (size) => {
                    const conditions = [];
                    const winLength = (size === 3) ? 3 : (size === 4 ? 4 : 5);
                    for (let r = 0; r < size; r++) {
                        for (let c = 0; c <= size - winLength; c++) {
                            const horizontal = [];
                            for (let i = 0; i < winLength; i++) horizontal.push(r * size + (c + i));
                            conditions.push(horizontal);
                            const vertical = [];
                            for (let i = 0; i < winLength; i++) vertical.push((c + i) * size + r);
                            conditions.push(vertical);
                        }
                    }
                    for (let r = 0; r <= size - winLength; r++) {
                        for (let c = 0; c <= size - winLength; c++) {
                            const diag1 = [];
                            const diag2 = [];
                            for (let i = 0; i < winLength; i++) {
                                diag1.push((r + i) * size + (c + i));
                                diag2.push((r + i) * size + (c + winLength - 1 - i));
                            }
                            conditions.push(diag1);
                            conditions.push(diag2);
                        }
                    }
                    return conditions;
                },
                initializeBoard: (isOnlineEvent = false) => {
                    if (!isOnlineEvent) {
                        const settings = getSettingsFromUI();
                        boardSize = settings.boardSize;
                    }
                    gameActive = true; currentPlayer = 'O'; oQueue = []; xQueue = [];
                    boardState = Array(boardSize * boardSize).fill('');
                    winningConditions = ticTacToeLogic.generateWinningConditions(boardSize);
                    boardElement.innerHTML = ''; boardElement.className = `board-${boardSize}x${boardSize}`; 
                    resultOverlay.style.display = 'none';
                    for (let i = 0; i < boardSize * boardSize; i++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell'); cell.setAttribute('data-index', i);
                        cell.innerHTML = '&nbsp;';
                        cell.addEventListener('click', handleCellClick); boardElement.appendChild(cell);
                    }
                    if (isOnlineEvent) { if (currentGameLog.length > 1) sessionLog.push(currentGameLog); } else { sessionLog = []; }
                    currentGameLog = []; turnCounter = 0; 
                    statusDisplay.textContent = `プレイヤー ${currentPlayer} の番です`;
                    boardElement.classList.remove('game-over');
                    const msg = isOnlineEvent ? '新しい対戦を開始しました。' : 'ゲームを開始しました。';
                    addLog(msg, [...boardState]);
                    updateSettingDependenciesUI();
                },
                handleCellClick: (e) => {
                    const clickedCell = e.target.closest('.cell');
                    if (!clickedCell) return;
                    const cellIndex = parseInt(clickedCell.getAttribute('data-index'));
                    if (!gameActive || boardState[cellIndex] !== '') return;
                    if (isOnlineGame) {
                        if (!isMyTurn || myPlayerMark === 'SPECTATOR') return;
                        socket.send(JSON.stringify({ type: 'move', cellIndex: cellIndex, gameType: 'tictactoe' }));
                    } else {
                        ticTacToeLogic.applyMove(cellIndex, currentPlayer, false); 
                        if (gameActive) ticTacToeLogic.switchPlayer(); 
                    }
                },
                applyMove: (cellIndex, player, isFromServer = false) => {
                    const limitMode = limitModeCheckbox.checked;
                    let logMessageDetail = '';
                    if (limitMode && boardSize === 3) {
                        const queue = (player === 'O') ? oQueue : xQueue;
                        if (queue.length >= 3) {
                            const indexToClear = queue.shift();
                            boardState[indexToClear] = '';
                            document.querySelector(`.cell[data-index="${indexToClear}"]`).innerHTML = '&nbsp;';
                            document.querySelector(`.cell[data-index="${indexToClear}"]`).classList.remove('o', 'x');
                            logMessageDetail = ` (古い駒 (マス ${indexToClear + 1}) が消去)`;
                        }
                    }
                    boardState[cellIndex] = player;
                    const cell = document.querySelector(`.cell[data-index="${cellIndex}"]`);
                    if (cell) {
                        cell.textContent = player; cell.classList.remove('o', 'x'); cell.classList.add(player.toLowerCase()); 
                    }
                    if (boardSize === 3) { const queue = (player === 'O') ? oQueue : xQueue; queue.push(cellIndex); }
                    addLog(`プレイヤー ${player} が マス${cellIndex + 1} に配置。${logMessageDetail}`, [...boardState]);
                    ticTacToeLogic.updateOldestHighlight(); 
                    if (ticTacToeLogic.checkWin(player)) { 
                        ticTacToeLogic.clearAllHighlights(); gameActive = false;
                        if (!isOnlineGame) { statusDisplay.textContent = `プレイヤー ${player} の勝利です！`; addLog(`プレイヤー ${player} が勝利しました。`, [...boardState]); showResult('win'); }
                    } else if (ticTacToeLogic.checkDraw()) { 
                        gameActive = false;
                        if (!isOnlineGame) { statusDisplay.textContent = '引き分けです！'; addLog('引き分けになりました。', [...boardState]); showResult('draw'); }
                    }
                },
                checkWin: (player) => {
                    for (const condition of winningConditions) { if (condition.every(index => boardState[index] === player)) return true; }
                    return false;
                },
                checkDraw: () => { return !boardState.includes(''); },
                switchPlayer: () => {
                    currentPlayer = currentPlayer === 'O' ? 'X' : 'O';
                    if (!isOnlineGame) statusDisplay.textContent = `プレイヤー ${currentPlayer} の番です`;
                    ticTacToeLogic.updateOldestHighlight(); 
                },
                updateOldestHighlight: () => {
                    ticTacToeLogic.clearAllHighlights(); 
                    if (!limitModeCheckbox.checked || !highlightOldestCheckbox.checked) return;
                    const queue = (currentPlayer === 'O') ? oQueue : xQueue;
                    if (queue.length >= 3) {
                        const indexToHighlight = queue[0];
                        const cell = document.querySelector(`.cell[data-index="${indexToHighlight}"]`);
                        if (cell) cell.classList.add('highlight-oldest');
                    }
                },
                clearAllHighlights: () => { document.querySelectorAll('.cell.highlight-oldest').forEach(cell => { cell.classList.remove('highlight-oldest'); }); }
            };

            const othelloLogic = {
                gameName: 'オセロ',
                directions: [-9, -8, -7, -1, 1, 7, 8, 9],
                initializeBoard: (isOnlineEvent = false) => {
                    gameActive = true; boardSize = 8; currentPlayer = 'O'; 
                    boardState = Array(64).fill('');
                    boardState[27] = 'X'; boardState[36] = 'X'; boardState[28] = 'O'; boardState[35] = 'O'; 
                    boardElement.innerHTML = ''; boardElement.className = 'board-othello'; resultOverlay.style.display = 'none';
                    othelloLogic.renderBoard(boardState);
                    updateOthelloScoreDisplay({ O: 2, X: 2 });
                    if (!isOnlineEvent) {
                        othelloLogic.updateHints(); statusDisplay.textContent = `黒(O)の番です`; addLog('オセロを開始しました。', [...boardState]);
                    } else {
                        if (currentGameLog.length > 1) sessionLog.push(currentGameLog); currentGameLog = []; turnCounter = 0; addLog('新しい対戦(オセロ)を開始しました。', [...boardState]);
                    }
                },
                renderBoard: (state) => {
                    boardElement.innerHTML = ''; boardElement.className = 'board-othello'; 
                    for (let i = 0; i < 64; i++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell-othello'); cell.setAttribute('data-index', i);
                        cell.addEventListener('click', handleCellClick); 
                        if(state[i]) {
                            const discClass = state[i] === 'O' ? 'disc-black' : 'disc-white';
                            cell.innerHTML = `<div class="disc ${discClass}"></div>`;
                        }
                        boardElement.appendChild(cell);
                    }
                },
                updateHints: () => {
                    document.querySelectorAll('.hint').forEach(h => h.classList.remove('hint'));
                    if (!gameActive) return;
                    const validMoves = othelloLogic.getValidMoves(boardState, currentPlayer);
                    validMoves.forEach(index => {
                        const cell = document.querySelector(`.cell-othello[data-index="${index}"]`);
                        if (cell) cell.classList.add('hint');
                    });
                },
                handleCellClick: (e) => {
                    const clickedCell = e.target.closest('.cell-othello');
                    if (!clickedCell) return;
                    const cellIndex = parseInt(clickedCell.getAttribute('data-index'));
                    if (!gameActive || boardState[cellIndex] !== '') return;
                    if (isOnlineGame) {
                        if (!isMyTurn || myPlayerMark === 'SPECTATOR') return;
                        socket.send(JSON.stringify({ type: 'move', cellIndex: cellIndex, gameType: 'othello' }));
                    } else {
                        const validMoves = othelloLogic.getValidMoves(boardState, currentPlayer);
                        if (validMoves.includes(cellIndex)) {
                            othelloLogic.applyMove(cellIndex, currentPlayer, false);
                            if (gameActive) othelloLogic.switchPlayer();
                        }
                    }
                },
                updateBoardState: (newState, nextPlayer, lastPlayer) => {
                    boardState = newState; currentPlayer = nextPlayer; othelloLogic.renderBoard(boardState);
                    const playerStr = lastPlayer === 'O' ? '黒(O)' : '白(X)';
                    addLog(`プレイヤー ${playerStr} が置きました。`, [...boardState]);
                    if (isMyTurn) othelloLogic.updateHints();
                    updateOthelloScoreDisplay(othelloLogic.getScores(boardState));
                },
                applyMove: (cellIndex, player, isFromServer = false) => {
                    const opponent = player === 'O' ? 'X' : 'O';
                    const flips = othelloLogic.getFlips(boardState, cellIndex, player, opponent);
                    boardState[cellIndex] = player; flips.forEach(i => boardState[i] = player);
                    othelloLogic.renderBoard(boardState);
                    addLog(`プレイヤー ${player} が マス${cellIndex + 1} に配置。`, [...boardState]);
                    updateOthelloScoreDisplay(othelloLogic.getScores(boardState));
                },
                switchPlayer: () => {
                    let opponent = currentPlayer === 'O' ? 'X' : 'O'; currentPlayer = opponent;
                    let validMoves = othelloLogic.getValidMoves(boardState, currentPlayer);
                    if (validMoves.length === 0) {
                        statusDisplay.textContent = `${currentPlayer === 'O' ? '黒(O)' : '白(X)'} はパスしました。`;
                        currentPlayer = (currentPlayer === 'O' ? 'X' : 'O');
                        validMoves = othelloLogic.getValidMoves(boardState, currentPlayer);
                        if (validMoves.length === 0) { othelloLogic.endGame(); return; }
                    }
                    statusDisplay.textContent = `${currentPlayer === 'O' ? '黒(O)' : '白(X)'}の番です`;
                    othelloLogic.updateHints();
                },
                endGame: () => {
                    gameActive = false;
                    const scores = othelloLogic.getScores(boardState);
                    let resultText = `黒(O): ${scores.O} - 白(X): ${scores.X}  `;
                    let result = 'DRAW';
                    if (scores.O > scores.X) { resultText += "黒(O)の勝利！"; result = 'O'; }
                    else if (scores.X > scores.O) { resultText += "白(X)の勝利！"; result = 'X'; }
                    else { resultText += "引き分け！"; }
                    statusDisplay.textContent = resultText;
                    if (isOnlineGame && isHost) {
                         socket.send(JSON.stringify({ type: 'gameOver', result: result, scores: scores, gameType: 'othello' }));
                    } else if (!isOnlineGame) {
                         addLog(resultText, [...boardState]);
                         if (result === 'DRAW') showResult('draw');
                         else showResult(result === 'O' ? 'win' : 'lose');
                    }
                },
                getValidMoves: (board, player) => {
                    const opponent = player === 'O' ? 'X' : 'O';
                    const moves = [];
                    for (let i = 0; i < 64; i++) {
                        if (board[i] === '') { if (othelloLogic.getFlips(board, i, player, opponent).length > 0) moves.push(i); }
                    }
                    return moves;
                },
                getFlips: (board, index, player, opponent) => {
                    const flips = [];
                    const col = index % 8;
                    othelloLogic.directions.forEach(dir => {
                        const path = [];
                        let i = index + dir;
                        if (i < 0 || i > 63) return;
                        let c = i % 8;
                        if (Math.abs(c - col) > 1) return;
                        while (Math.floor(i / 8) >= 0 && Math.floor(i / 8) < 8 && i % 8 >= 0 && i % 8 < 8 && board[i] === opponent) {
                            path.push(i); const prev_i = i; i += dir;
                            if (i < 0 || i > 63) { path.length = 0; break; }
                            if (Math.abs((i % 8) - (prev_i % 8)) > 1) { path.length = 0; break; }
                        }
                        if (i >= 0 && i < 64 && board[i] === player && path.length > 0) flips.push(...path);
                    });
                    return flips;
                },
                getScores: (board) => {
                    let oScore = 0; let xScore = 0;
                    board.forEach(cell => { if (cell === 'O') oScore++; else if (cell === 'X') xScore++; });
                    return { O: oScore, X: xScore };
                }
            };

            // WebSocket
            function initializeWebSocket() {
                if (socket && socket.readyState === WebSocket.OPEN) socket.close();
                createRoomBtn.disabled = true; joinRoomBtn.disabled = true; showRoomListBtn.disabled = true;
                try {
                    roomIdDisplay.textContent = 'サーバーに接続中...'; roomIdDisplay.style.display = 'block';
                    socket = new WebSocket(serverUrl);
                    socket.onopen = () => {
                        roomIdDisplay.textContent = 'サーバーに接続しました。';
                        createRoomBtn.disabled = false; joinRoomBtn.disabled = false; showRoomListBtn.disabled = false;
                    };
                    socket.onmessage = (event) => handleWebSocketMessage(JSON.parse(event.data));
                    socket.onclose = () => {
                        if (isOnlineGame) { alert('サーバーから切断されました。ゲームをリセットします。'); isOnlineGame = false; fullReset(); }
                    };
                    socket.onerror = (error) => { alert('サーバー接続に失敗しました。'); roomIdDisplay.style.display = 'none'; createRoomBtn.disabled = false; joinRoomBtn.disabled = false; showRoomListBtn.disabled = false; };
                } catch (error) { alert('サーバー接続に失敗しました。\n' + error.message); roomIdDisplay.style.display = 'none'; }
            }
            
            function handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'roomJoined':
                        isOnlineGame = true; isHost = data.isHost; myPlayerMark = data.mark; isMyTurn = false; currentRoomId = data.roomId; isReady = false; 
                        closeModal('roomListModal'); scores = { win: 0, lose: 0, draw: 0 }; updateScoreDisplay(); closeModal('onlineModal');
                        switchGame(data.gameType); applySettings(data.lobby.settings, true);
                        if(data.lobby.playerColors) applyColors(data.lobby.playerColors);
                        showLobbyScreen(); updateLobbyUI(data.lobby);
                        sidePanel.style.display = 'flex'; if(chatToggleBtn) chatToggleBtn.style.display = 'block'; handleResize();
                        roomIdDisplayHeader.textContent = `ルームID: ${currentRoomId}`; roomIdDisplayHeader.style.display = 'block';
                        if (data.currentBoardState) {
                            if (data.gameType === 'othello') {
                                othelloLogic.updateBoardState(data.currentBoardState, data.currentPlayer);
                                statusDisplay.textContent = `観戦中: ${data.currentPlayer === 'O' ? '黒(O)' : '白(X)'} の番です`;
                            } else {
                                boardState = data.currentBoardState; currentPlayer = data.currentPlayer;
                                boardElement.innerHTML = ''; boardElement.className = `board-${boardSize}x${boardSize}`;
                                for (let i = 0; i < boardSize * boardSize; i++) {
                                    const cell = document.createElement('div');
                                    cell.classList.add('cell'); cell.setAttribute('data-index', i);
                                    const mark = boardState[i];
                                    if (mark) { cell.textContent = mark; cell.classList.add(mark.toLowerCase()); } else { cell.innerHTML = '&nbsp;'; }
                                    cell.addEventListener('click', handleCellClick); boardElement.appendChild(cell);
                                }
                                statusDisplay.textContent = `観戦中: プレイヤー ${data.currentPlayer} の番です`;
                            }
                            showMatchScreen();
                        }
                        break;
                    case 'lobbyUpdate':
                        if(data.newHostUsername) isHost = (data.newHostUsername === username);
                        const amIInSlot = data.lobby.playerO?.username === username || data.lobby.playerX?.username === username;
                        if (!amIInSlot && myPlayerMark !== 'SPECTATOR') { myPlayerMark = 'SPECTATOR'; isReady = false; }
                        lockSettings(isOnlineGame && !isHost); 
                        if (data.lobby.playerColors) {
                            if (myPlayerMark === 'O' && data.lobby.playerColors.O !== myLocalColorPref) { myLocalColorPref = data.lobby.playerColors.O; }
                            if (myPlayerMark === 'X' && data.lobby.playerColors.X !== myLocalColorPref) { myLocalColorPref = data.lobby.playerColors.X; }
                            applyColors(data.lobby.playerColors);
                        }
                        updateLobbyUI(data.lobby);
                        break;
                    case 'settingsUpdated':
                        applySettings(data.settings, true); lockSettings(isOnlineGame && !isHost); updateLobbySlotDisplay(); break;
                    case 'gameChanged':
                        switchGame(data.gameType); applySettings(data.settings, true); break;
                    case 'youTookSlot':
                        myPlayerMark = data.slot; updateLobbyUI(data.lobby); break;
                    case 'youLeftSlot':
                        myPlayerMark = 'SPECTATOR'; isReady = false; updateLobbyUI(data.lobby); break;
                    case 'matchStarting':
                        if (autoReturnTimer) clearTimeout(autoReturnTimer); autoReturnTimer = null; isReady = false; 
                        gameLogic.initializeBoard(true); 
                        currentPlayer = data.firstPlayer; myPlayerMark = data.myMark; isMyTurn = (myPlayerMark === currentPlayer);
                        updatePlayerNameDisplay();
                        if (currentGameType === 'othello') {
                            const myColor = myPlayerMark === 'O' ? '黒' : (myPlayerMark === 'X' ? '白' : '観戦者');
                            const turnColor = currentPlayer === 'O' ? '黒' : '白';
                            if (myPlayerMark === 'SPECTATOR') statusDisplay.textContent = `観戦中: ${turnColor} (${currentPlayer}) の番です`;
                            else { statusDisplay.textContent = `あなたは ${myColor}(${myPlayerMark}) です。` + (isMyTurn ? "あなたの番です。" : "相手の番です。"); }
                            if(isMyTurn) othelloLogic.updateHints(); 
                        } else {
                            if (myPlayerMark === 'SPECTATOR') statusDisplay.textContent = `観戦中: プレイヤー ${currentPlayer} の番です`;
                            else { statusDisplay.textContent = `あなたは ${myPlayerMark} です。` + (isMyTurn ? "あなたの番です。" : "相手の番です。"); }
                        }
                        showMatchScreen(); lockSettings(true);
                        break;
                    case 'boardUpdate':
                        isMyTurn = (myPlayerMark === data.nextPlayer);
                        updatePlayerNameDisplay(data.nextPlayer);
                        if (data.gameType === 'tictactoe') {
                            ticTacToeLogic.applyMove(data.cellIndex, data.player, true);
                            currentPlayer = data.nextPlayer;
                            statusDisplay.textContent = isMyTurn ? "あなたの番です。" : "相手の番です。";
                        } else if (data.gameType === 'othello') {
                            othelloLogic.updateBoardState(data.boardState, data.nextPlayer, data.player);
                            const myColor = myPlayerMark === 'O' ? '黒' : (myPlayerMark === 'X' ? '白' : '観戦者');
                            if (!data.nextPlayer) { statusDisplay.textContent = "対戦終了処理中..."; } 
                            else {
                                const turnColor = data.nextPlayer === 'O' ? '黒' : '白';
                                if (myPlayerMark === 'SPECTATOR') statusDisplay.textContent = `観戦中: ${turnColor} (${data.nextPlayer}) の番です`;
                                else statusDisplay.textContent = `あなたは ${myColor}(${myPlayerMark}) です。` + (isMyTurn ? "あなたの番です。" : "相手の番です。");
                            }
                        }
                        break;
                    case 'passTurn':
                        isMyTurn = (myPlayerMark === data.nextPlayer); currentPlayer = data.nextPlayer;
                        alert(`${data.passedPlayer === 'O' ? '黒(O)' : '白(X)'} はパスしました。`);
                        updatePlayerNameDisplay(data.nextPlayer);
                        const myColor = myPlayerMark === 'O' ? '黒' : (myPlayerMark === 'X' ? '白' : '観戦者');
                        const turnColor = data.nextPlayer === 'O' ? '黒' : '白';
                        if (myPlayerMark === 'SPECTATOR') statusDisplay.textContent = `観戦中: ${turnColor} (${data.nextPlayer}) の番です`;
                        else {
                            statusDisplay.textContent = `あなたは ${myColor}(${myPlayerMark}) です。` + (isMyTurn ? "あなたの番です。" : "相手の番です。");
                            if(isMyTurn) othelloLogic.updateHints(); 
                        }
                        break;
                    case 'gameOver':
                        if (data.boardState && data.gameType === 'othello') {
                            boardState = data.boardState; othelloLogic.renderBoard(boardState);
                            if (data.scores) updateOthelloScoreDisplay(data.scores);
                        }
                        gameActive = false;
                        let resultType = data.result;
                        let statusText = '';
                        if (data.gameType === 'othello' && data.scores) {
                            const scores = data.scores; statusText = `黒(O): ${scores.O} - 白(X): ${scores.X}。 `; updateOthelloScoreDisplay(scores);
                        }
                        if (resultType === 'DRAW') {
                            statusText += '引き分けです！'; showResult('draw');
                            if (myPlayerMark !== 'SPECTATOR') scores.draw++;
                        } else {
                            const iWon = (resultType === myPlayerMark);
                            if (myPlayerMark === 'SPECTATOR') {
                                const winnerName = (currentGameType === 'othello') ? (resultType === 'O' ? '黒(O)' : '白(X)') : `プレイヤー ${resultType}`;
                                statusText += `${winnerName} の勝利です！`;
                                showResult(resultType === 'O' ? 'win' : 'lose');
                            } else {
                                statusText += iWon ? "あなたの勝利です！" : "あなたの敗北です...";
                                showResult(iWon ? 'win' : 'lose'); scores[iWon ? 'win' : 'lose']++;
                            }
                        }
                        statusDisplay.textContent = statusText; updateScoreDisplay();
                        addLog(statusText, [...boardState]); 
                        showPostGameScreen();
                        if (autoReturnTimer) clearTimeout(autoReturnTimer);
                        autoReturnTimer = setTimeout(() => {
                            if (isOnlineGame && socket && socket.readyState === WebSocket.OPEN && !gameActive) {
                                socket.send(JSON.stringify({ type: 'returnToLobby' })); showLobbyScreen(); autoReturnTimer = null;
                            }
                        }, 10000); 
                        break;
                    case 'opponentDisconnected':
                        if (autoReturnTimer) clearTimeout(autoReturnTimer); autoReturnTimer = null;
                        alert('対戦相手が切断しました。待機画面に戻ります。');
                        myPlayerMark = 'SPECTATOR'; showLobbyScreen(); updateLobbyUI(data.lobby); break;
                    case 'roomListUpdate': updateRoomList(data.rooms, data.page, data.totalPages); break;
                    case 'error': alert('エラー: ' + data.message); createRoomBtn.disabled = false; joinRoomBtn.disabled = false; showRoomListBtn.disabled = false; isHost = false; break;
                    case 'newChat': addChatMessage(data.from, data.message, false, data.isNotification); break;
                }
            }
            
            function createRoom() {
                username = usernameInputOnline.value.trim();
                if (!username) { alert('ユーザーネームを入力してください。'); return; }
                const currentSettings = getSettingsFromUI();
                currentSettings.isPublic = isPublicToggle.checked;
                currentSettings.maxPlayers = parseInt(maxPlayersInput.value, 10);
                socket.send(JSON.stringify({ type: 'createRoom', username: username, settings: currentSettings, gameType: currentGameType }));
            }
            function joinRoom(id = null) {
                username = usernameInputOnline.value.trim();
                if (!username) { alert('ユーザーネームを入力してください。'); return; }
                const roomId = id || roomIdInput.value.toUpperCase();
                if (!roomId) { alert('ルームIDを入力してください。'); return; }
                socket.send(JSON.stringify({ type: 'joinRoom', username: username, roomId: roomId }));
            }
            function sendSettingsUpdate() {
                if (isHost && isOnlineGame && socket && socket.readyState === WebSocket.OPEN) {
                    const settings = getSettingsFromUI();
                    settings.maxPlayers = parseInt(maxPlayersInput.value, 10);
                    socket.send(JSON.stringify({ type: 'updateSettings', settings: settings }));
                }
            }
            function addChatMessage(from, message, isSelf, isNotification = false) {
                const msgDiv = document.createElement('div');
                if (isNotification) { msgDiv.className = 'chat-notification'; msgDiv.textContent = message; } 
                else {
                    msgDiv.classList.add('chat-message', isSelf ? 'self' : 'other');
                    const bubble = document.createElement('div'); bubble.className = 'chat-bubble'; bubble.textContent = message;
                    if (!isSelf) { const meta = document.createElement('div'); meta.className = 'chat-meta'; meta.textContent = from; msgDiv.appendChild(meta); }
                    msgDiv.appendChild(bubble);
                }
                chatMessages.appendChild(msgDiv); chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            function sendChat() {
                const message = chatInput.value.trim();
                if (message && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'chat', message: message })); addChatMessage(username, message, true); chatInput.value = '';
                }
            }
            
            function openModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'flex'; }
            function closeModal(modalId) { const modal = document.getElementById(modalId); if (modal) modal.style.display = 'none'; }
            closeBtns.forEach(btn => btn.addEventListener('click', () => closeModal(btn.getAttribute('data-modal-id'))));
            window.addEventListener('click', (e) => modals.forEach(modal => { if (e.target === modal) closeModal(modal.id); }));

            function showButtonSet(setName) {
                ['local', 'lobby', 'in-game', 'post-game'].forEach(set => { document.getElementById(`buttonSet-${set}`).style.display = (set === setName) ? 'block' : 'none'; });
            }
            function showLobbyScreen() {
                if (autoReturnTimer) clearTimeout(autoReturnTimer); autoReturnTimer = null;
                gameActive = false; statusDisplay.textContent = '待機画面 (ロビー)';
                lobbyContainer.style.display = 'block'; boardContainer.style.display = 'none';
                showButtonSet('lobby'); settingsBtnLobby.style.display = 'flex';
                primaryActionBtnLobby.disabled = (myPlayerMark === 'SPECTATOR');
                if (isReady) { primaryActionBtnLobby.textContent = '準備解除'; primaryActionBtnLobby.classList.add('ready'); } 
                else { primaryActionBtnLobby.textContent = '準備完了'; primaryActionBtnLobby.classList.remove('ready'); }
                lockSettings(isOnlineGame && !isHost); scoreBoard.style.display = 'flex'; roomIdDisplayHeader.style.display = 'block'; othelloScoreBoard.style.display = 'none'; matchPlayerInfo.style.display = 'none';
            }
            function showMatchScreen() {
                lobbyContainer.style.display = 'none'; boardContainer.style.display = 'block';
                showButtonSet('in-game');
                primaryActionBtnGame.style.display = (myPlayerMark === 'SPECTATOR') ? 'none' : 'flex'; primaryActionBtnGame.disabled = false; 
                lockSettings(true);
                // プレイヤー名表示更新
                updatePlayerNameDisplay(currentPlayer);
                matchPlayerInfo.style.display = 'flex'; // 表示オン
                if(currentGameType === 'othello') othelloScoreBoard.style.display = 'flex';
            }
            function showPostGameScreen() { showButtonSet('post-game'); primaryActionBtnPostGame.disabled = false; matchPlayerInfo.style.display = 'flex'; }
            function showResult(resultType) {
                boardElement.classList.add('game-over'); resultText.classList.remove('win', 'lose', 'draw');
                if (resultType === 'win') { resultText.textContent = 'WIN'; resultText.classList.add('win'); } 
                else if (resultType === 'lose') { resultText.textContent = 'LOSE'; resultText.classList.add('lose'); } 
                else { resultText.textContent = 'DRAW'; resultText.classList.add('draw'); }
                resultOverlay.style.display = 'block';
            }
            function updateScoreDisplay() { scoreWinCount.textContent = scores.win; scoreLoseCount.textContent = scores.lose; scoreDrawCount.textContent = scores.draw; }
            function updateOthelloScoreDisplay(scores) {
                const blackCount = document.getElementById('othelloScoreBlack'); const whiteCount = document.getElementById('othelloScoreWhite');
                if (blackCount && whiteCount) { blackCount.textContent = scores.O; whiteCount.textContent = scores.X; }
            }
            function updateLobbySlotDisplay() {
                let player1Mark = 'O'; let player2Mark = 'X';
                if (currentGameType === 'othello') { player1Mark = '黒'; player2Mark = '白'; }
                const currentOrder = document.querySelector('input[name="playerOrder"]:checked').value; const isRandom = (currentOrder === 'random');
                const oMark = isRandom ? '(?) ' : `(${player1Mark}) `; const xMark = isRandom ? '(?) ' : `(${player2Mark}) `;
                
                // updateLobbyUIで一括更新するためここでは何もしない(または必要なら再描画)
            }

            // プレイヤー名表示更新関数
            function updatePlayerNameDisplay(activePlayerMark = null) {
                let labelO = 'O'; let labelX = 'X';
                if(currentGameType === 'othello') { labelO = '黒(O)'; labelX = '白(X)'; }
                
                playerDisplayO.textContent = `${labelO}: ${currentRoomPlayerNames.O}`;
                playerDisplayX.textContent = `${labelX}: ${currentRoomPlayerNames.X}`;
                
                playerDisplayO.classList.remove('active');
                playerDisplayX.classList.remove('active');
                
                if (activePlayerMark === 'O') playerDisplayO.classList.add('active');
                if (activePlayerMark === 'X') playerDisplayX.classList.add('active');
            }

            function updateLobbyUI(lobby) {
                let player1Mark = 'O'; let player2Mark = 'X';
                if (currentGameType === 'othello') { player1Mark = '黒'; player2Mark = '白'; }
                const currentOrder = document.querySelector('input[name="playerOrder"]:checked').value; const isRandom = (currentOrder === 'random');
                const oMark = isRandom ? '(?) ' : `(${player1Mark}) `; const xMark = isRandom ? '(?) ' : `(${player2Mark}) `;
                
                // ホスト判定用
                const hostUser = lobby.hostUsername;

                const slotO = lobby.playerO; const slotO_Name = playerSlotO.querySelector('.player-slot-name'); const slotO_Btn = playerSlotO.querySelector('.slot-btn');
                const oldKickBtnO = playerSlotO.querySelector('.kick-btn'); if (oldKickBtnO) oldKickBtnO.remove();
                if (slotO) {
                    const hostMark = (slotO.username === hostUser) ? ' 👑' : '';
                    slotO_Name.textContent = `${oMark}${slotO.username}${hostMark}`; slotO_Name.classList.remove('empty');
                    currentRoomPlayerNames.O = slotO.username; // 名前保存
                    if (slotO.username === username) {
                        slotO_Btn.style.display = 'flex'; slotO_Btn.textContent = 'スロット退出'; slotO_Btn.className = 'slot-btn leave';
                        slotO_Btn.onclick = () => socket.send(JSON.stringify({ type: 'leaveSlot', slot: 'O' }));
                    } else {
                        slotO_Btn.style.display = 'none';
                        if (isHost) {
                            const kickBtn = document.createElement('button'); kickBtn.className = 'slot-btn leave kick-btn'; kickBtn.textContent = '除外';
                            kickBtn.onclick = () => { usernameToKick = slotO.username; kickConfirmText.textContent = `${usernameToKick} をスロットから除外しますか？ (10秒間参加不可)`; openModal('kickConfirmModal'); };
                            playerSlotO.appendChild(kickBtn);
                        }
                    }
                } else {
                    slotO_Name.textContent = `${oMark}空き`; slotO_Name.classList.add('empty');
                    currentRoomPlayerNames.O = '?';
                    slotO_Btn.style.display = (myPlayerMark === 'SPECTATOR') ? 'flex' : 'none'; slotO_Btn.textContent = '参加する'; slotO_Btn.className = 'slot-btn';
                    slotO_Btn.onclick = () => socket.send(JSON.stringify({ type: 'takeSlot', slot: 'O', color: myLocalColorPref }));
                }

                const slotX = lobby.playerX; const slotX_Name = playerSlotX.querySelector('.player-slot-name'); const slotX_Btn = playerSlotX.querySelector('.slot-btn');
                const oldKickBtnX = playerSlotX.querySelector('.kick-btn'); if (oldKickBtnX) oldKickBtnX.remove();
                if (slotX) {
                    const hostMark = (slotX.username === hostUser) ? ' 👑' : '';
                    slotX_Name.textContent = `${xMark}${slotX.username}${hostMark}`; slotX_Name.classList.remove('empty');
                    currentRoomPlayerNames.X = slotX.username; // 名前保存
                    if (slotX.username === username) {
                        slotX_Btn.style.display = 'flex'; slotX_Btn.textContent = 'スロット退出'; slotX_Btn.className = 'slot-btn leave';
                        slotX_Btn.onclick = () => socket.send(JSON.stringify({ type: 'leaveSlot', slot: 'X' }));
                    } else {
                        slotX_Btn.style.display = 'none';
                        if (isHost) {
                            const kickBtn = document.createElement('button'); kickBtn.className = 'slot-btn leave kick-btn'; kickBtn.textContent = '除外';
                            kickBtn.onclick = () => { usernameToKick = slotX.username; kickConfirmText.textContent = `${usernameToKick} をスロットから除外しますか？ (10秒間参加不可)`; openModal('kickConfirmModal'); };
                            playerSlotX.appendChild(kickBtn);
                        }
                    }
                } else {
                    slotX_Name.textContent = `${xMark}空き`; slotX_Name.classList.add('empty');
                    currentRoomPlayerNames.X = '?';
                    slotX_Btn.style.display = (myPlayerMark === 'SPECTATOR') ? 'flex' : 'none'; slotX_Btn.textContent = '参加する'; slotX_Btn.className = 'slot-btn';
                    slotX_Btn.onclick = () => socket.send(JSON.stringify({ type: 'takeSlot', slot: 'X', color: myLocalColorPref }));
                }
                
                spectatorList.innerHTML = '';
                lobby.spectators.forEach(spec => {
                    const li = document.createElement('li'); const nameSpan = document.createElement('span'); 
                    const hostMark = (spec.username === hostUser) ? ' 👑' : '';
                    nameSpan.textContent = spec.username + hostMark;
                    if (spec.username === username) { nameSpan.textContent += ' (あなた)'; nameSpan.style.fontWeight = 'bold'; }
                    li.appendChild(nameSpan);
                    if (isHost && spec.username !== username) {
                        const kickBtn = document.createElement('button'); kickBtn.className = 'slot-btn leave'; kickBtn.textContent = 'Kick';
                        kickBtn.onclick = () => { usernameToKick = spec.username; kickConfirmText.textContent = `${usernameToKick} をルームからキックしますか？ (強制退出)`; openModal('kickConfirmModal'); };
                        li.appendChild(kickBtn);
                    }
                    spectatorList.appendChild(li);
                });
                primaryActionBtnLobby.disabled = (myPlayerMark === 'SPECTATOR');
                if (isReady) { primaryActionBtnLobby.textContent = '準備解除'; primaryActionBtnLobby.classList.add('ready'); } 
                else { primaryActionBtnLobby.textContent = '準備完了'; primaryActionBtnLobby.classList.remove('ready'); }
            }

            function addLog(message, boardSnapshot) {
                turnCounter++; 
                const snapshotSize = Math.sqrt(boardSnapshot.length);
                currentGameLog.push({ message: message, board: [...boardSnapshot], turn: turnCounter, boardSize: (currentGameType === 'othello') ? 8 : snapshotSize, gameType: currentGameType });
            }

            showLogList = function() {
                logModalTitle.textContent = "ログ確認 (試合一覧)"; logContent.innerHTML = ''; const listContainer = document.createElement('div'); listContainer.className = 'log-list-container';
                const allLogs = sessionLog.concat(currentGameLog.length > 0 ? [currentGameLog] : []); 
                if (allLogs.length === 0) { listContainer.innerHTML = '<p>表示できるログがありません。</p>'; } 
                else {
                    allLogs.forEach((matchLog, index) => {
                        const item = document.createElement('div'); item.className = 'log-list-item';
                        const logEntry = matchLog[0] || {};
                        const logGameType = logEntry.gameType || (logEntry.board && logEntry.board.length > 25 ? 'othello' : 'tictactoe');
                        const logBoardSize = logEntry.boardSize || (logGameType === 'othello' ? 8 : (logEntry.board ? Math.sqrt(logEntry.board.length) : 3));
                        const gameName = logGameType === 'othello' ? 'オセロ' : 'OXゲーム';
                        const isCurrent = (index === sessionLog.length) && (currentGameLog.length > 0);
                        if (matchLog.isImported) { item.textContent = `インポートしたログ (${gameName} ${logBoardSize}x${logBoardSize})`; } 
                        else { item.textContent = `第 ${index + 1} 試合 (${gameName} ${logBoardSize}x${logBoardSize}) (${isCurrent ? (gameActive ? '進行中' : '終了') : '終了'})`; }
                        item.onclick = () => showMatchLogDetail(index, isCurrent); listContainer.appendChild(item);
                    });
                }
                logContent.appendChild(listContainer); openModal('logModal');
            }

            showMatchLogDetail = function(matchIndex, isCurrent = false) {
                const matchLog = isCurrent ? currentGameLog : sessionLog[matchIndex]; if (!matchLog) return;
                const matchNumber = isCurrent ? sessionLog.length + 1 : matchIndex + 1;
                const logEntry = matchLog[0] || {};
                const logGameType = logEntry.gameType || (logEntry.board && logEntry.board.length > 25 ? 'othello' : 'tictactoe');
                const logBoardSize = logEntry.boardSize || (logGameType === 'othello' ? 8 : (logEntry.board ? Math.sqrt(logEntry.board.length) : 3));
                const gameName = logGameType === 'othello' ? 'オセロ' : 'OXゲーム';
                logModalTitle.textContent = (matchLog.isImported ? `インポートログ詳細 (${gameName} ${logBoardSize}x${logBoardSize})` : `第 ${matchNumber} 試合 (${gameName} ${logBoardSize}x${logBoardSize}) のログ詳細`);
                logContent.innerHTML = '';
                const controls = document.createElement('div'); controls.className = 'log-detail-controls';
                controls.innerHTML = `<button class="log-detail-back-btn" onclick="showLogList()">← 試合一覧に戻る</button><button class="log-detail-save-btn" onclick="exportMatchLog(${isCurrent ? "'current'" : matchIndex})">この試合のログを保存</button>`;
                logContent.appendChild(controls);
                matchLog.forEach(entry => {
                    const entryDiv = document.createElement('div'); entryDiv.className = 'log-entry';
                    const dynamicGameType = entry.gameType || (entry.board && entry.board.length > 25 ? 'othello' : 'tictactoe');
                    const dynamicBoardSize = entry.boardSize || (dynamicGameType === 'othello' ? 8 : (entry.board ? Math.sqrt(entry.board.length) : 3));
                    const miniCellSize = Math.max(10, Math.floor(90 / dynamicBoardSize));
                    let boardHtml = '';
                    if (dynamicGameType === 'othello') {
                        boardHtml = `<div class="mini-board othello-log" style="grid-template-columns: repeat(${dynamicBoardSize}, 1fr); width: ${miniCellSize * dynamicBoardSize}px; height: ${miniCellSize * dynamicBoardSize}px;">`;
                        (entry.board || []).forEach(mark => {
                            if (mark === 'O') { boardHtml += `<div class="mini-cell othello-cell"><div class="mini-disc o"></div></div>`; } 
                            else if (mark === 'X') { boardHtml += `<div class="mini-cell othello-cell"><div class="mini-disc x"></div></div>`; } 
                            else { boardHtml += `<div class="mini-cell othello-cell"></div>`; }
                        });
                    } else {
                        boardHtml = `<div class="mini-board" style="grid-template-columns: repeat(${dynamicBoardSize}, 1fr); width: ${miniCellSize * dynamicBoardSize}px; height: ${miniCellSize * dynamicBoardSize}px;">`;
                        (entry.board || []).forEach(mark => {
                            const fontSize = dynamicBoardSize === 3 ? '1.2rem' : (dynamicBoardSize === 4 ? '0.9rem' : '0.7rem');
                            if (mark === 'O') { boardHtml += `<div class="mini-cell o" style="font-size: ${fontSize};">O</div>`; } 
                            else if (mark === 'X') { boardHtml += `<div class="mini-cell x" style="font-size: ${fontSize};">X</div>`; } 
                            else { boardHtml += `<div class="mini-cell" style="font-size: ${fontSize};">&nbsp;</div>`; }
                        });
                    }
                    boardHtml += '</div>';
                    entryDiv.innerHTML = `<div class="log-text"><h3>${entry.turn - 1} 手目</h3><p>${entry.message}</p></div>${boardHtml}`;
                    logContent.appendChild(entryDiv);
                });
                openModal('logModal');
            }

            exportMatchLog = function(matchIndex) {
                const isCurrent = (matchIndex === 'current'); const matchLog = isCurrent ? currentGameLog : sessionLog[matchIndex]; const matchNumber = isCurrent ? sessionLog.length + 1 : matchIndex + 1;
                const logEntry = matchLog[0] || {}; const logGameType = logEntry.gameType || (logEntry.board && logEntry.board.length > 25 ? 'othello' : 'tictactoe'); const logBoardSize = logEntry.boardSize || (logGameType === 'othello' ? 8 : (logEntry.board ? Math.sqrt(logEntry.board.length) : 3));
                if (!matchLog || (matchLog.length === 0) || (matchLog.length === 1 && !matchLog.isImported && !isCurrent)) { alert('保存するログがありません。'); return; }
                const logData = JSON.stringify(matchLog, null, 2); const blob = new Blob([logData], { type: 'application/json' }); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.download = `game_log_${logGameType}_match_${matchLog.isImported ? 'imported' : matchNumber}_${logBoardSize}x${logBoardSize}_${Date.now()}.json`; a.href = url; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); alert(`ログを保存しました。`);
            }

            function importLog(event) {
                const file = event.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedLog = JSON.parse(e.target.result); if (!Array.isArray(importedLog) || !importedLog[0] || !importedLog[0].board) throw new Error('無効なログファイル形式です。');
                        fullReset(); importedLog.isImported = true; sessionLog = [importedLog]; currentGameLog = [];
                        const settings = importedLog[0] || {}; const gameType = settings.gameType || (settings.board.length > 25 ? 'othello' : 'tictactoe');
                        switchGame(gameType);
                        applySettings({ boardSize: settings.boardSize || (gameType === 'othello' ? 8 : Math.sqrt(settings.board.length)), playerOrder: 'assigned', limitMode: false, highlightOldest: false }, false);
                        alert('ログを読み込みました。「ログ確認」で表示します。'); showLogList();
                    } catch (error) { alert('ログの読み込みに失敗しました。\n' + error.message); }
                }; reader.onerror = () => { alert('ファイルの読み込みに失敗しました。'); }; reader.readAsText(file); event.target.value = null;
            }
            
            function updateRoomList(rooms, page, totalPages) {
                publicRoomList.innerHTML = '';
                if (rooms.length === 0) publicRoomList.innerHTML = '<p style="text-align: center; padding: 20px; color: #999;">公開中のルームはありません。</p>';
                rooms.forEach(room => {
                    const item = document.createElement('div'); item.className = 'room-list-item';
                    const gameName = room.gameType === 'othello' ? 'オセロ' : 'OXゲーム';
                    item.innerHTML = `<div><div class="room-list-id">ID: ${room.id} (${gameName}) ${room.inGame ? '(試合中)' : ''}</div><div class="room-list-count">人数: ${room.count} / ${room.max}</div></div><button class="room-list-join-btn">参加</button>`;
                    item.querySelector('.room-list-join-btn').addEventListener('click', (e) => {
                        e.stopPropagation(); username = usernameInputOnline.value.trim();
                        if (!username) { alert('先にユーザーネームを入力してください。'); closeModal('roomListModal'); openModal('onlineModal'); return; }
                        joinRoom(room.id);
                    });
                    publicRoomList.appendChild(item);
                });
                currentRoomPage = page; roomListPageNum.textContent = `${page} / ${totalPages}`; roomListPagePrev.disabled = (page <= 1); roomListPageNext.disabled = (page >= totalPages);
            }
            
            function getRoomList(page = 1) {
                if (socket && socket.readyState === WebSocket.OPEN) socket.send(JSON.stringify({ type: 'getRoomList', page: page }));
                else { alert('サーバーに接続していません。「オンライン対戦」を再度開いてください。'); initializeWebSocket(); }
            }

            // イベントリスナー
            logBtn.addEventListener('click', showLogList); logBtnLobby.addEventListener('click', showLogList); logBtnPostGame.addEventListener('click', () => showMatchLogDetail(0, true)); importLogInput.addEventListener('change', importLog);
            settingsBtn.addEventListener('click', () => openModal('settingsModal')); settingsBtnLobby.addEventListener('click', () => openModal('settingsModal'));
            boardSizeRadios.forEach(radio => radio.addEventListener('change', () => { updateSettingDependencies(true); checkSecretCode(radio.value); }));
            playerOrderRadios.forEach(radio => radio.addEventListener('change', () => { sendSettingsUpdate(); updateLobbySlotDisplay(); }));
            limitModeCheckbox.addEventListener('change', () => updateSettingDependencies(true));
            highlightOldestCheckbox.addEventListener('change', () => { if(currentGameType === 'tictactoe') ticTacToeLogic.updateOldestHighlight(); sendSettingsUpdate(); });
            dockChatToggle.addEventListener('change', handleResize); maxPlayersInput.addEventListener('change', sendSettingsUpdate); 
            onlineBtn.addEventListener('click', () => { initializeWebSocket(); openModal('onlineModal'); });
            createRoomBtn.addEventListener('click', createRoom); joinRoomBtn.addEventListener('click', () => joinRoom()); 
            showRoomListBtn.addEventListener('click', () => { getRoomList(1); openModal('roomListModal'); });
            roomListRefreshBtn.addEventListener('click', () => getRoomList(currentRoomPage)); roomListPagePrev.addEventListener('click', () => getRoomList(currentRoomPage - 1)); roomListPageNext.addEventListener('click', () => getRoomList(currentRoomPage + 1));
            
            const exitFunc = () => openModal('exitConfirmModal'); exitBtnLobby.addEventListener('click', exitFunc); exitBtnGame.addEventListener('click', exitFunc); exitBtnPostGame.addEventListener('click', exitFunc); cancelExitBtn.addEventListener('click', () => closeModal('exitConfirmModal'));
            confirmExitBtn.addEventListener('click', () => { closeModal('exitConfirmModal'); isOnlineGame = false; fullReset(); });
            cancelKickBtn.addEventListener('click', () => closeModal('kickConfirmModal')); confirmKickBtn.addEventListener('click', () => { if (usernameToKick) socket.send(JSON.stringify({ type: 'kickPlayer', username: usernameToKick })); closeModal('kickConfirmModal'); usernameToKick = ''; });
            localResetBtn.addEventListener('click', () => gameLogic.initializeBoard(false)); 
            
            primaryActionBtnLobby.addEventListener('click', () => {
                isReady = !isReady; socket.send(JSON.stringify({ type: 'setReady', isReady: isReady }));
                if (isReady) { statusDisplay.textContent = '相手の準備を待っています...'; primaryActionBtnLobby.textContent = '準備解除'; primaryActionBtnLobby.classList.add('ready'); } 
                else { statusDisplay.textContent = '待機画面 (ロビー)'; primaryActionBtnLobby.textContent = '準備完了'; primaryActionBtnLobby.classList.remove('ready'); }
            });
            primaryActionBtnGame.addEventListener('click', () => {
                if (confirm('本当に降参しますか？\n(あなたの敗北となります)')) { socket.send(JSON.stringify({ type: 'surrender', gameType: currentGameType })); statusDisplay.textContent = '降参しました...'; primaryActionBtnGame.disabled = true; }
            });
            primaryActionBtnPostGame.addEventListener('click', () => {
                if (autoReturnTimer) clearTimeout(autoReturnTimer); autoReturnTimer = null; socket.send(JSON.stringify({ type: 'returnToLobby' })); showLobbyScreen();
            });
            
            const chatModalFunc = () => openModal('chatModal'); chatBtnLobby.addEventListener('click', chatModalFunc); chatBtnGame.addEventListener('click', chatModalFunc); chatBtnPostGame.addEventListener('click', chatModalFunc);
            chatSendBtn.addEventListener('click', sendChat); chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat(); } });
            
            function checkSecretCode(value) {
                if (settingsModal.style.display === 'none' || settingsModal.style.display === '') { secretIndex = 0; return; }
                if (value === secretCode[secretIndex]) {
                    secretIndex++;
                    if (secretIndex === secretCode.length) {
                        document.getElementById('colorSelectContainer').style.display = 'flex';
                        alert("隠しコマンド成功！カラーパレットが解放されました。"); secretIndex = 0; 
                    }
                } else { secretIndex = 0; if (value === secretCode[secretIndex]) secretIndex++; }
            }

            document.querySelectorAll('input[name="gameType"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const newGameType = e.target.value; const currentOrder = document.querySelector('input[name="playerOrder"]:checked').value;
                    if (isOnlineGame && isHost) socket.send(JSON.stringify({ type: 'changeGame', gameType: newGameType, playerOrder: currentOrder }));
                    else if (!isOnlineGame) switchGame(newGameType);
                    else { alert('ゲームの変更はホストのみ可能です。'); document.getElementById(`game${currentGameType}`).checked = true; }
                });
            });

            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (e.target.classList.contains('disabled')) return;
                    const color = e.target.dataset.color;
                    myLocalColorPref = color;
                    if (isOnlineGame && (myPlayerMark === 'O' || myPlayerMark === 'X')) {
                        socket.send(JSON.stringify({ type: 'updateColor', color: color }));
                    } else {
                        if (!isOnlineGame) applyColors({ O: color, X: null }); 
                        else updatePaletteUI();
                    }
                });
            });
            document.getElementById('resetColorBtn').addEventListener('click', () => {
                myLocalColorPref = null;
                if (isOnlineGame && (myPlayerMark === 'O' || myPlayerMark === 'X')) {
                    socket.send(JSON.stringify({ type: 'updateColor', color: null }));
                } else {
                    if (!isOnlineGame) applyColors({ O: null, X: null });
                    else updatePaletteUI();
                }
            });

            helpBtn.addEventListener('click', () => { updateHelpContent(); openModal('helpModal'); });

            function handleResize() {
                const isDocked = dockChatToggle.checked; const isPC = window.innerWidth >= 801;
                if (isPC && isOnlineGame) {
                    if (isDocked) {
                        sidePanel.style.display = 'flex'; if (!sidePanel.contains(chatContainer)) sidePanel.appendChild(chatContainer);
                        body.classList.remove('chat-dock-hidden'); [chatBtnLobby, chatBtnGame, chatBtnPostGame].forEach(btn => btn.style.display = 'none');
                    } else {
                        sidePanel.style.display = 'none'; if (!chatContainerModal.contains(chatContainer)) chatContainerModal.appendChild(chatContainer);
                        body.classList.add('chat-dock-hidden'); [chatBtnLobby, chatBtnGame, chatBtnPostGame].forEach(btn => btn.style.display = 'flex');
                    }
                } else {
                    sidePanel.style.display = 'none'; if (!chatContainerModal.contains(chatContainer)) chatContainerModal.appendChild(chatContainer);
                    body.classList.add('chat-dock-hidden'); if (isOnlineGame) [chatBtnLobby, chatBtnGame, chatBtnPostGame].forEach(btn => btn.style.display = 'flex');
                }
            }
            window.addEventListener('resize', handleResize);
            
            gameLogic = ticTacToeLogic;
            fullReset();
        });
    </script>
</body>

</html>





